# OpenNI: video and audio
[OpenNI][1]
[OpenNI api][2]
[csdn blog OpenNI][3]
[csdn blog][4]
[cnblog calibration][5]
[cvvision][6]

## 0. There're 4 main classes:
>- openni::OpenNI: access of API
>- openni::Device
>- openni::VideoStream
>- openni::VideoFramRef: get one video stream frame from video stream data

## 1. Dataflow
>- (1). initialize openni environment  
>- (2). new openni::Device  
>- (3). open device  
>- (4). new openni::VideoStream  
>- (5). appoint VideoStream to get what type of data(infra/rgb/depth)  
>- (6). get data stream and process   
>- (7). destroy data stream  
>- (8). close device   
>- (9). shutdown openni environment  

## 2. Device()
when there're several sensors connected to pc:
1. get devices list by **openni::numerateDevices()**. 
2. get URI(Uniform Resource Identifier) by **openni::DeviceInfo::getUri()**, the output of this method is the input of **openni::Device::open()**
3. **Device::close()**: all the opened devices must be closed
4. **Device::isValid()**
5. **Device::hasSensor()**: sensor type 
>>- (1). SENSOR_IR
>>- (2). SENSOR_COLOR
>>- (3). SENSOR_DEPTH

## 3. VideoStream()
embedded all the data stream created by Device() class.
**VideoStream::create() -> VideoStream::start() -> VideoStream::stop()**


---

# Camera calibration
>- addChessboardPoints(): read series chess board images and detect corner points
>- calibrate(): get camera intrinsic/extrinsic matrix
>- remap(): implement initUndistortRectifyMap
>- addPoints(): be called after addChessboardPoints(), or manually call this method to add cornor points

Zhang Zhenyou
[blog about camera calibration](http://blog.csdn.net/dcrmg/article/details/52939318)
Why: in order to get intrinsic matrix of camera and extrinsic matrix -> to rectify the images got -> to get undistored(little distored) images
input: all the iner corner image coordinates and spatial coordinates
output: intrinsic and extrinsic matrix 

1. calibration board
2. extract corner information of each calib image
3. corner subpix
4. draw iner corner(optional, just for display)
5. calibration
6. evaluate
7. check, unrectify image


[opencv python](http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_calib3d/py_calibration/py_calibration.html)
[calibration math](http://blog.csdn.net/aptx704610875/article/details/48914043)
1. chessboard images: at least 3 (different position, different orientation, different angles), 10~20
2. extract corner information of each chessboard image:  
cv::findChessboardCorners(8bit grey image / rgb image, chessboard iner corner rows and cols, &corner image coordinates, flag for calibration)
**3**. extract cornersubpix information of each chessboard image:  
cv::cornerSubPix(better 8bit grey image, first corner image coordinates, window size, zero zone, criteria)
(another approach is: cv::find4QuadCornerSubpix) ?: what's the differences?
4. draw iner corner:  
cv::drawChessboardCorners(8bit grey image / rgb image, chessboard rows and corners, corner image coordinates, flag for whether all the corner points are detected)
5. calibration:   
cv::calibrateCamera(spatial coordinates, image coordinates, image pixel size, camera intrinsic matrix, distortion matrix, rotation vector, translation vector, flags for calibration approach)
6. evaluate:  
re-projection error
cv::projectPoints  
7. check, rectify distord image:  
(1). approach 1: cv::initUndistortRectifyMap and cv::remap
(2). approach 2: cv::undistort


requires white space(like a square-thick border, the wider the better) around the board to make the detection more robust in various environments. Otherwise, if there is no border and the background is dark, the outer black squares cannot be segmented properly and so the square grouping and ordering algorithm fails

the opencv ```imread(), videoCapture()``` state that by default for 3-channel color images the data is stored in **BGR** order.  
Because BGR color format was popular among camera manufacturers and software providers. BGR was a choice made for historical reasons.
---

if an image size is 640*480, depth is 16 bits, than it has ? M data:
> 640\*480\*16 bit = 4915200 bit = 614400 bytes = 600 kb = 0.58 M


---  

[1]http://openni.ru/openni-programmers-guide/index.html  
[2]http://www.openni.ru/wp-content/doxygen/html/index.html  
[3]http://blog.csdn.net/app_12062011/article/details/52738147  
[4]http://blog.csdn.net/App_12062011  
[5]http://www.cnblogs.com/haoxing990/p/4589461.html  
[6]http://www.cvvision.cn/cv.html   

